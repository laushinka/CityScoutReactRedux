Object.defineProperty(exports,"__esModule",{value:true});var _isPlainObject2=require("lodash/isPlainObject");var _isPlainObject3=_interopRequireDefault(_isPlainObject2);var _includes2=require("lodash/includes");var _includes3=_interopRequireDefault(_includes2);var _flatten2=require("lodash/flatten");var _flatten3=_interopRequireDefault(_flatten2);
var _data=require("./data");var _data2=_interopRequireDefault(_data);
var _axis=require("./axis");var _axis2=_interopRequireDefault(_axis);
var _scale=require("./scale");var _scale2=_interopRequireDefault(_scale);
var _victoryCore=require("victory-core");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}exports.default=

{
getDomain:function getDomain(props,axis){
var propsDomain=this.getDomainFromProps(props,axis);
if(propsDomain){
return this.padDomain(propsDomain,props,axis);
}
var categoryDomain=this.getDomainFromCategories(props,axis);
if(categoryDomain){
return this.padDomain(categoryDomain,props,axis);
}
var dataset=_data2.default.getData(props);
var domain=this.getDomainFromData(props,axis,dataset);
return this.cleanDomain(this.padDomain(domain,props,axis),props,axis);
},

cleanDomain:function cleanDomain(domain,props,axis){
// Some scale types break when certain data is supplies. This method will
// remove data points that break scales. So far this method only removes
// zeroes for log scales
// TODO other cases?
var scaleType=_scale2.default.getScaleType(props,axis);

if(scaleType!=="log"){
return domain;
}

var rules=function rules(dom){
var almostZero=dom[0]<0||dom[1]<0?-1/Number.MAX_SAFE_INTEGER:
1/Number.MAX_SAFE_INTEGER;
var domainOne=dom[0]===0?almostZero:dom[0];
var domainTwo=dom[1]===0?almostZero:dom[1];
return[domainOne,domainTwo];
};

return rules(domain);
},

getDomainWithZero:function getDomainWithZero(props,axis){var _this=this;
var propsDomain=this.getDomainFromProps(props,axis);
if(propsDomain){
return this.cleanDomain(this.padDomain(propsDomain,props,axis),props,axis);
}var
horizontal=props.horizontal;
var ensureZero=function ensureZero(domain){
var isDependent=axis==="y"&&!horizontal||axis==="x"&&horizontal;
var min=_victoryCore.Collection.getMinValue(domain,0);
var max=_victoryCore.Collection.getMaxValue(domain,0);
var zeroDomain=isDependent?[min,max]:domain;
return _this.padDomain(zeroDomain,props,axis);
};
var categoryDomain=this.getDomainFromCategories(props,axis);
if(categoryDomain){
return this.cleanDomain(this.padDomain(ensureZero(categoryDomain),props,axis),props,axis);
}
var dataset=_data2.default.getData(props);
var domain=ensureZero(this.getDomainFromData(props,axis,dataset));
return this.cleanDomain(this.padDomain(domain,props,axis),props,axis);
},

getDomainFromProps:function getDomainFromProps(props,axis){
if(props.domain&&props.domain[axis]){
return props.domain[axis];
}else if(props.domain&&Array.isArray(props.domain)){
return props.domain;
}
},

getDomainFromData:function getDomainFromData(props,axis,dataset){
var currentAxis=_axis2.default.getCurrentAxis(axis,props.horizontal);
var allData=(0,_flatten3.default)(dataset).map(function(datum){return datum[currentAxis];});

if(allData.length<1){
return _scale2.default.getBaseScale(props,axis).domain();
}

var min=_victoryCore.Collection.getMinValue(allData);
var max=_victoryCore.Collection.getMaxValue(allData);
// TODO: is this the correct behavior, or should we just error. How do we
// handle charts with just one data point?
if(min===max){
var adjustedMax=max===0?1:max+max;
return[0,adjustedMax];
}
return[min,max];
},

getDomainFromTickValues:function getDomainFromTickValues(props){
var domain=void 0;
if(_axis2.default.stringTicks(props)){
domain=[1,props.tickValues.length];
}else{
// coerce ticks to numbers
var ticks=props.tickValues.map(function(value){return+value;});
domain=[Math.min.apply(Math,_toConsumableArray(ticks)),Math.max.apply(Math,_toConsumableArray(ticks))];
}
if(_axis2.default.isVertical(props)){
domain.reverse();
}
return domain;
},

getDomainFromCategories:function getDomainFromCategories(props,axis){
var categories=_data2.default.getCategories(props,axis);
if(!categories){
return undefined;
}
var stringArray=_victoryCore.Collection.containsStrings(categories)?
_data2.default.getStringsFromCategories(props,axis):[];
var stringMap=stringArray.length===0?null:
stringArray.reduce(function(memo,string,index){
memo[string]=index+1;
return memo;
},{});
var categoryValues=stringMap?
categories.map(function(value){return stringMap[value];}):categories;
return[Math.min.apply(Math,_toConsumableArray(categoryValues)),Math.max.apply(Math,_toConsumableArray(categoryValues))];
},

getDomainFromGroupedData:function getDomainFromGroupedData(props,axis,datasets){var
horizontal=props.horizontal;
var dependent=axis==="x"&&!horizontal||axis==="y"&&horizontal;
if(dependent&&props.categories){
return this.getDomainFromCategories(props,axis);
}
var globalDomain=this.getDomainFromData(props,axis,datasets);

// find the cumulative max for stacked chart types
var cumulativeData=!dependent?
this.getCumulativeData(props,axis,datasets):[];

var cumulativeMaxArray=cumulativeData.map(function(dataset){
return dataset.reduce(function(memo,val){
return val>0?memo+val:memo;
},0);
});
var cumulativeMinArray=cumulativeData.map(function(dataset){
return dataset.reduce(function(memo,val){
return val<0?memo+val:memo;
},0);
});

var cumulativeMin=Math.min.apply(Math,_toConsumableArray(cumulativeMinArray));
// use greatest min / max
var domainMin=cumulativeMin<0?cumulativeMin:Math.min.apply(Math,_toConsumableArray(globalDomain));
var domainMax=Math.max.apply(Math,_toConsumableArray(globalDomain).concat(_toConsumableArray(cumulativeMaxArray)));
// TODO: is this the correct behavior, or should we just error. How do we
// handle charts with just one data point?
if(domainMin===domainMax){
var adjustedMax=domainMax===0?1:domainMax;
return[0,adjustedMax];
}
return[domainMin,domainMax];
},

getCumulativeData:function getCumulativeData(props,axis,datasets){
var currentAxis=_axis2.default.getCurrentAxis(axis,props.horizontal);
var categories=[];
var axisValues=[];
datasets.forEach(function(dataset){
dataset.forEach(function(data){
if(data.category!==undefined&&!(0,_includes3.default)(categories,data.category)){
categories.push(data.category);
}else if(!(0,_includes3.default)(axisValues,data[currentAxis])){
axisValues.push(data[currentAxis]);
}
});
});

var _dataByCategory=function _dataByCategory(){
return categories.map(function(value){
return datasets.reduce(function(prev,data){
return data.category===value?prev.concat(data[axis]):prev;
},[]);
});
};

var _dataByIndex=function _dataByIndex(){
return axisValues.map(function(value,index){
return datasets.map(function(data){return data[index]&&data[index][currentAxis];});
});
};

return categories.length===0?_dataByIndex():_dataByCategory();
},

getDomainPadding:function getDomainPadding(props,axis){
var formatPadding=function formatPadding(padding){
return Array.isArray(padding)?
{left:padding[0],right:padding[1]}:{left:padding,right:padding};
};

return(0,_isPlainObject3.default)(props.domainPadding)?
formatPadding(props.domainPadding[axis]):formatPadding(props.domainPadding);
},

padDomain:function padDomain(domain,props,axis){
if(!props.domainPadding){
return domain;
}

var padding=this.getDomainPadding(props,axis);
if(!padding.left&&!padding.right){
return domain;
}

var domainMin=_victoryCore.Collection.getMinValue(domain);
var domainMax=_victoryCore.Collection.getMaxValue(domain);
var range=_victoryCore.Helpers.getRange(props,axis);
var rangeExtent=Math.abs(Math.max.apply(Math,_toConsumableArray(range))-Math.min.apply(Math,_toConsumableArray(range)));

var paddingLeft=Math.abs(domainMax-domainMin)*padding.left/rangeExtent;
var paddingRight=Math.abs(domainMax-domainMin)*padding.right/rangeExtent;
// don't make the axes cross if they aren't already
var adjustedMin=domainMin>=0&&domainMin-paddingLeft<=0?
0:domainMin.valueOf()-paddingLeft;

var adjustedMax=domainMax<=0&&domainMax+paddingRight>=0?
0:domainMax.valueOf()+paddingRight;

return domainMin instanceof Date||domainMax instanceof Date?
[new Date(adjustedMin),new Date(adjustedMax)]:[adjustedMin,adjustedMax];
},

orientDomain:function orientDomain(domain,orientations,axis){
// If the other axis is in a reversed orientation, the domain of this axis
// needs to be reversed
var otherAxis=axis==="x"?"y":"x";
var defaultOrientation=function defaultOrientation(ax){return ax==="x"?"bottom":"left";};
var flippedAxis=orientations.x==="left"||orientations.x==="right";
var standardOrientation=flippedAxis?
orientations[otherAxis]===defaultOrientation(axis):
orientations[otherAxis]===defaultOrientation(otherAxis);
if(flippedAxis){
return standardOrientation?domain.concat().reverse():domain;
}else{
return standardOrientation?domain:domain.concat().reverse();
}
}};