Object.defineProperty(exports,"__esModule",{value:true});var _last2=require("lodash/last");var _last3=_interopRequireDefault(_last2);var _range2=require("lodash/range");var _range3=_interopRequireDefault(_range2);var _uniq2=require("lodash/uniq");var _uniq3=_interopRequireDefault(_uniq2);var _assign2=require("lodash/assign");var _assign3=_interopRequireDefault(_assign2);
var _victoryCore=require("victory-core");
var _scale=require("./scale");var _scale2=_interopRequireDefault(_scale);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}exports.default=

{
// String Data
createStringMap:function createStringMap(props,axis){
var stringsFromAxes=this.getStringsFromAxes(props,axis);
var stringsFromCategories=this.getStringsFromCategories(props,axis);
var stringsFromData=_victoryCore.Helpers.getStringsFromData(props,axis);

var allStrings=(0,_uniq3.default)([].concat(_toConsumableArray(stringsFromAxes),_toConsumableArray(stringsFromCategories),_toConsumableArray(stringsFromData)));
return allStrings.length===0?null:
allStrings.reduce(function(memo,string,index){
memo[string]=index+1;
return memo;
},{});
},

getStringsFromAxes:function getStringsFromAxes(props,axis){
if(!props.tickValues||!Array.isArray(props.tickValues)&&!props.tickValues[axis]){
return[];
}
var tickValueArray=props.tickValues[axis]||props.tickValues;
return tickValueArray.filter(function(val){return typeof val==="string";});
},

getStringsFromCategories:function getStringsFromCategories(props,axis){
if(!props.categories){
return[];
}
var categories=this.getCategories(props,axis);
var categoryStrings=categories&&categories.filter(function(val){return typeof val==="string";});
return categoryStrings?_victoryCore.Collection.removeUndefined(categoryStrings):[];
},

getCategories:function getCategories(props,axis){
return props.categories&&!Array.isArray(props.categories)?
props.categories[axis]:props.categories;
},

getData:function getData(props){
if(props.data){
if(props.data.length<1){
_victoryCore.Log.warn("This is an empty dataset.");
return[];
}else{
return this.formatData(props.data,props);
}
}else{
var generatedData=(props.x||props.y)&&this.generateData(props);
return this.formatData(generatedData,props);
}
},

generateData:function generateData(props){
// create an array of values evenly spaced across the x domain that include domain min/max
var domain=props.domain?props.domain.x||props.domain:
_scale2.default.getBaseScale(props,"x").domain();
var samples=props.samples||1;
var domainMax=Math.max.apply(Math,_toConsumableArray(domain));
var domainMin=Math.min.apply(Math,_toConsumableArray(domain));
var step=(domainMax-domainMin)/samples;
var values=(0,_range3.default)(domainMin,domainMax,step).map(function(v){
return{x:v,y:v};
});
return(0,_last3.default)(values).x===domainMax?
values:values.concat([{x:domainMax,y:domainMax}]);
},

formatData:function formatData(dataset,props,stringMap){
if(!dataset){
return[];
}
stringMap=stringMap||{
x:this.createStringMap(props,"x"),
y:this.createStringMap(props,"y")};

var accessor={
x:_victoryCore.Helpers.createAccessor(props.x),
y:_victoryCore.Helpers.createAccessor(props.y)};

return this.cleanData(dataset,props).map(function(datum){
var x=accessor.x(datum);
var y=accessor.y(datum);
return(0,_assign3.default)(
{},
datum,
{x:x,y:y},
// map string data to numeric values, and add names
typeof x==="string"?{x:stringMap.x[x],xName:x}:{},
typeof y==="string"?{y:stringMap.y[y],yName:y}:{});

});
},

cleanData:function cleanData(dataset,props){
// Some scale types break when certain data is supplies. This method will
// remove data points that break scales. So far this method only removes
// zeroes for log scales
// TODO other cases?
var scaleType={
x:_scale2.default.getScaleType(props,"x"),
y:_scale2.default.getScaleType(props,"y")};

var accessor={
x:_victoryCore.Helpers.createAccessor(props.x),
y:_victoryCore.Helpers.createAccessor(props.y)};

if(scaleType.x!=="log"&&scaleType.y!=="log"){
return dataset;
}
var rules=function rules(datum,axis){
return scaleType[axis]==="log"?accessor[axis](datum)!==0:true;
};
return dataset.filter(function(datum){
return rules(datum,"x")&&rules(datum,"y");
});
}};